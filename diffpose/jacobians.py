# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/api/06_jacobians.ipynb.

# %% auto 0
__all__ = ['JacobianDRR', 'plot_img_jacobian', 'preconditioner']

# %% ../notebooks/api/06_jacobians.ipynb 3
import torch
from diffdrr.pose import convert


class JacobianDRR(torch.nn.Module):
    """Computes the Jacobian of a DRR wrt pose parameters."""

    def __init__(
        self,
        drr,
        rotation,
        translation,
        parameterization,
        convention=None,
    ):
        super().__init__()
        self.drr = drr
        self.rotation = torch.nn.Parameter(rotation.clone())
        self.translation = torch.nn.Parameter(translation.clone())
        self.parameterization = parameterization
        self.convention = convention

    def forward(self):
        I = self.cast(self.rotation, self.translation)
        J = torch.autograd.functional.jacobian(
            self.cast,
            (self.rotation, self.translation),
            vectorize=True,
            strategy="forward-mode",
        )
        J = torch.concat([self.permute(j) for j in J], dim=0)
        return I, J

    def cast(self, rotation, translation):
        pose = convert(
            rotation,
            translation,
            parameterization=self.parameterization,
            convention=self.convention,
        )
        return self.drr(pose)

    def permute(self, x):
        return x.permute(-1, 0, 2, 3, 1, 4)[..., 0, 0]

# %% ../notebooks/api/06_jacobians.ipynb 4
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter


def plot_img_jacobian(I, J, **kwargs):
    def fmt(x, pos):
        a, b = f"{x:.0e}".split("e")
        a = float(a)
        b = int(b)
        if a == 0:
            return "0"
        elif b == 0:
            if a < 0:
                return "-1"
            else:
                return "1"
        elif a < 0:
            return rf"$-10^{{{b}}}$"
        else:
            return rf"$10^{{{b}}}$"

    plt.figure(figsize=(10, 4), dpi=300, constrained_layout=True)
    plt.subplot(2, 4, 2)
    plt.title("J(yaw)")
    plt.imshow(J[0].squeeze().cpu().detach(), **kwargs)
    plt.colorbar(format=FuncFormatter(fmt))
    plt.axis("off")
    plt.subplot(2, 4, 3)
    plt.title("J(pitch)")
    plt.imshow(J[1].squeeze().cpu().detach(), **kwargs)
    plt.colorbar(format=FuncFormatter(fmt))
    plt.axis("off")
    plt.subplot(2, 4, 4)
    plt.title("J(roll)")
    plt.imshow(J[2].squeeze().cpu().detach(), **kwargs)
    plt.colorbar(format=FuncFormatter(fmt))
    plt.axis("off")
    plt.subplot(2, 4, 6)
    plt.title("J(x)")
    plt.imshow(J[3].squeeze().cpu().detach(), **kwargs)
    plt.colorbar(format=FuncFormatter(fmt))
    plt.axis("off")
    plt.subplot(2, 4, 7)
    plt.title("J(y)")
    plt.imshow(J[4].squeeze().cpu().detach(), **kwargs)
    plt.colorbar(format=FuncFormatter(fmt))
    plt.axis("off")
    plt.subplot(2, 4, 8)
    plt.title("J(z)")
    plt.imshow(J[5].squeeze().cpu().detach(), **kwargs)
    plt.colorbar(format=FuncFormatter(fmt))
    plt.axis("off")
    plt.subplot(2, 4, 1)
    plt.title("img")
    plt.imshow(I.cpu().detach().squeeze(), cmap="gray")
    plt.axis("off")
    plt.colorbar()
    plt.show()

# %% ../notebooks/api/06_jacobians.ipynb 5
def preconditioner(jacobian, p=-0.5, λ=1e-1, μ=1e-8):
    """Calculate the inverse preconditioning matrix."""
    # Calculate the covariance matrix
    vecj = jacobian.flatten(start_dim=1)
    cov = vecj @ vecj.T

    # Apply a small dampening parameter
    eyelike = lambda A: torch.eye(A.shape[0]).to(A)
    cov += λ * torch.diag(torch.diag(cov)) + μ * eyelike(cov)

    # Calculate the preconditioning matrix
    eigenvalues, V = torch.linalg.eigh(cov)
    Dexp = torch.diag(eigenvalues.pow(p))
    return V @ Dexp @ V.T
